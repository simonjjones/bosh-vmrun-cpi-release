// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"bosh-vmrun-cpi/driver"
	"bosh-vmrun-cpi/vmx"
	"sync"
)

type FakeVmxBuilder struct {
	InitHardwareStub        func(string) error
	initHardwareMutex       sync.RWMutex
	initHardwareArgsForCall []struct {
		arg1 string
	}
	initHardwareReturns struct {
		result1 error
	}
	initHardwareReturnsOnCall map[int]struct {
		result1 error
	}
	AddNetworkInterfaceStub        func(string, string, string) error
	addNetworkInterfaceMutex       sync.RWMutex
	addNetworkInterfaceArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	addNetworkInterfaceReturns struct {
		result1 error
	}
	addNetworkInterfaceReturnsOnCall map[int]struct {
		result1 error
	}
	SetVMResourcesStub        func(int, int, string) error
	setVMResourcesMutex       sync.RWMutex
	setVMResourcesArgsForCall []struct {
		arg1 int
		arg2 int
		arg3 string
	}
	setVMResourcesReturns struct {
		result1 error
	}
	setVMResourcesReturnsOnCall map[int]struct {
		result1 error
	}
	AttachDiskStub        func(string, string) error
	attachDiskMutex       sync.RWMutex
	attachDiskArgsForCall []struct {
		arg1 string
		arg2 string
	}
	attachDiskReturns struct {
		result1 error
	}
	attachDiskReturnsOnCall map[int]struct {
		result1 error
	}
	DetachDiskStub        func(string, string) error
	detachDiskMutex       sync.RWMutex
	detachDiskArgsForCall []struct {
		arg1 string
		arg2 string
	}
	detachDiskReturns struct {
		result1 error
	}
	detachDiskReturnsOnCall map[int]struct {
		result1 error
	}
	AttachCdromStub        func(string, string) error
	attachCdromMutex       sync.RWMutex
	attachCdromArgsForCall []struct {
		arg1 string
		arg2 string
	}
	attachCdromReturns struct {
		result1 error
	}
	attachCdromReturnsOnCall map[int]struct {
		result1 error
	}
	VMInfoStub        func(string) (driver.VMInfo, error)
	vMInfoMutex       sync.RWMutex
	vMInfoArgsForCall []struct {
		arg1 string
	}
	vMInfoReturns struct {
		result1 driver.VMInfo
		result2 error
	}
	vMInfoReturnsOnCall map[int]struct {
		result1 driver.VMInfo
		result2 error
	}
	GetVmxStub        func(string) (*vmx.VM, error)
	getVmxMutex       sync.RWMutex
	getVmxArgsForCall []struct {
		arg1 string
	}
	getVmxReturns struct {
		result1 *vmx.VM
		result2 error
	}
	getVmxReturnsOnCall map[int]struct {
		result1 *vmx.VM
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeVmxBuilder) InitHardware(arg1 string) error {
	fake.initHardwareMutex.Lock()
	ret, specificReturn := fake.initHardwareReturnsOnCall[len(fake.initHardwareArgsForCall)]
	fake.initHardwareArgsForCall = append(fake.initHardwareArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("InitHardware", []interface{}{arg1})
	fake.initHardwareMutex.Unlock()
	if fake.InitHardwareStub != nil {
		return fake.InitHardwareStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.initHardwareReturns.result1
}

func (fake *FakeVmxBuilder) InitHardwareCallCount() int {
	fake.initHardwareMutex.RLock()
	defer fake.initHardwareMutex.RUnlock()
	return len(fake.initHardwareArgsForCall)
}

func (fake *FakeVmxBuilder) InitHardwareArgsForCall(i int) string {
	fake.initHardwareMutex.RLock()
	defer fake.initHardwareMutex.RUnlock()
	return fake.initHardwareArgsForCall[i].arg1
}

func (fake *FakeVmxBuilder) InitHardwareReturns(result1 error) {
	fake.InitHardwareStub = nil
	fake.initHardwareReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVmxBuilder) InitHardwareReturnsOnCall(i int, result1 error) {
	fake.InitHardwareStub = nil
	if fake.initHardwareReturnsOnCall == nil {
		fake.initHardwareReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initHardwareReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVmxBuilder) AddNetworkInterface(arg1 string, arg2 string, arg3 string) error {
	fake.addNetworkInterfaceMutex.Lock()
	ret, specificReturn := fake.addNetworkInterfaceReturnsOnCall[len(fake.addNetworkInterfaceArgsForCall)]
	fake.addNetworkInterfaceArgsForCall = append(fake.addNetworkInterfaceArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("AddNetworkInterface", []interface{}{arg1, arg2, arg3})
	fake.addNetworkInterfaceMutex.Unlock()
	if fake.AddNetworkInterfaceStub != nil {
		return fake.AddNetworkInterfaceStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.addNetworkInterfaceReturns.result1
}

func (fake *FakeVmxBuilder) AddNetworkInterfaceCallCount() int {
	fake.addNetworkInterfaceMutex.RLock()
	defer fake.addNetworkInterfaceMutex.RUnlock()
	return len(fake.addNetworkInterfaceArgsForCall)
}

func (fake *FakeVmxBuilder) AddNetworkInterfaceArgsForCall(i int) (string, string, string) {
	fake.addNetworkInterfaceMutex.RLock()
	defer fake.addNetworkInterfaceMutex.RUnlock()
	return fake.addNetworkInterfaceArgsForCall[i].arg1, fake.addNetworkInterfaceArgsForCall[i].arg2, fake.addNetworkInterfaceArgsForCall[i].arg3
}

func (fake *FakeVmxBuilder) AddNetworkInterfaceReturns(result1 error) {
	fake.AddNetworkInterfaceStub = nil
	fake.addNetworkInterfaceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVmxBuilder) AddNetworkInterfaceReturnsOnCall(i int, result1 error) {
	fake.AddNetworkInterfaceStub = nil
	if fake.addNetworkInterfaceReturnsOnCall == nil {
		fake.addNetworkInterfaceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addNetworkInterfaceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVmxBuilder) SetVMResources(arg1 int, arg2 int, arg3 string) error {
	fake.setVMResourcesMutex.Lock()
	ret, specificReturn := fake.setVMResourcesReturnsOnCall[len(fake.setVMResourcesArgsForCall)]
	fake.setVMResourcesArgsForCall = append(fake.setVMResourcesArgsForCall, struct {
		arg1 int
		arg2 int
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("SetVMResources", []interface{}{arg1, arg2, arg3})
	fake.setVMResourcesMutex.Unlock()
	if fake.SetVMResourcesStub != nil {
		return fake.SetVMResourcesStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setVMResourcesReturns.result1
}

func (fake *FakeVmxBuilder) SetVMResourcesCallCount() int {
	fake.setVMResourcesMutex.RLock()
	defer fake.setVMResourcesMutex.RUnlock()
	return len(fake.setVMResourcesArgsForCall)
}

func (fake *FakeVmxBuilder) SetVMResourcesArgsForCall(i int) (int, int, string) {
	fake.setVMResourcesMutex.RLock()
	defer fake.setVMResourcesMutex.RUnlock()
	return fake.setVMResourcesArgsForCall[i].arg1, fake.setVMResourcesArgsForCall[i].arg2, fake.setVMResourcesArgsForCall[i].arg3
}

func (fake *FakeVmxBuilder) SetVMResourcesReturns(result1 error) {
	fake.SetVMResourcesStub = nil
	fake.setVMResourcesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVmxBuilder) SetVMResourcesReturnsOnCall(i int, result1 error) {
	fake.SetVMResourcesStub = nil
	if fake.setVMResourcesReturnsOnCall == nil {
		fake.setVMResourcesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setVMResourcesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVmxBuilder) AttachDisk(arg1 string, arg2 string) error {
	fake.attachDiskMutex.Lock()
	ret, specificReturn := fake.attachDiskReturnsOnCall[len(fake.attachDiskArgsForCall)]
	fake.attachDiskArgsForCall = append(fake.attachDiskArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("AttachDisk", []interface{}{arg1, arg2})
	fake.attachDiskMutex.Unlock()
	if fake.AttachDiskStub != nil {
		return fake.AttachDiskStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.attachDiskReturns.result1
}

func (fake *FakeVmxBuilder) AttachDiskCallCount() int {
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	return len(fake.attachDiskArgsForCall)
}

func (fake *FakeVmxBuilder) AttachDiskArgsForCall(i int) (string, string) {
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	return fake.attachDiskArgsForCall[i].arg1, fake.attachDiskArgsForCall[i].arg2
}

func (fake *FakeVmxBuilder) AttachDiskReturns(result1 error) {
	fake.AttachDiskStub = nil
	fake.attachDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVmxBuilder) AttachDiskReturnsOnCall(i int, result1 error) {
	fake.AttachDiskStub = nil
	if fake.attachDiskReturnsOnCall == nil {
		fake.attachDiskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachDiskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVmxBuilder) DetachDisk(arg1 string, arg2 string) error {
	fake.detachDiskMutex.Lock()
	ret, specificReturn := fake.detachDiskReturnsOnCall[len(fake.detachDiskArgsForCall)]
	fake.detachDiskArgsForCall = append(fake.detachDiskArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("DetachDisk", []interface{}{arg1, arg2})
	fake.detachDiskMutex.Unlock()
	if fake.DetachDiskStub != nil {
		return fake.DetachDiskStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.detachDiskReturns.result1
}

func (fake *FakeVmxBuilder) DetachDiskCallCount() int {
	fake.detachDiskMutex.RLock()
	defer fake.detachDiskMutex.RUnlock()
	return len(fake.detachDiskArgsForCall)
}

func (fake *FakeVmxBuilder) DetachDiskArgsForCall(i int) (string, string) {
	fake.detachDiskMutex.RLock()
	defer fake.detachDiskMutex.RUnlock()
	return fake.detachDiskArgsForCall[i].arg1, fake.detachDiskArgsForCall[i].arg2
}

func (fake *FakeVmxBuilder) DetachDiskReturns(result1 error) {
	fake.DetachDiskStub = nil
	fake.detachDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVmxBuilder) DetachDiskReturnsOnCall(i int, result1 error) {
	fake.DetachDiskStub = nil
	if fake.detachDiskReturnsOnCall == nil {
		fake.detachDiskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.detachDiskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVmxBuilder) AttachCdrom(arg1 string, arg2 string) error {
	fake.attachCdromMutex.Lock()
	ret, specificReturn := fake.attachCdromReturnsOnCall[len(fake.attachCdromArgsForCall)]
	fake.attachCdromArgsForCall = append(fake.attachCdromArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("AttachCdrom", []interface{}{arg1, arg2})
	fake.attachCdromMutex.Unlock()
	if fake.AttachCdromStub != nil {
		return fake.AttachCdromStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.attachCdromReturns.result1
}

func (fake *FakeVmxBuilder) AttachCdromCallCount() int {
	fake.attachCdromMutex.RLock()
	defer fake.attachCdromMutex.RUnlock()
	return len(fake.attachCdromArgsForCall)
}

func (fake *FakeVmxBuilder) AttachCdromArgsForCall(i int) (string, string) {
	fake.attachCdromMutex.RLock()
	defer fake.attachCdromMutex.RUnlock()
	return fake.attachCdromArgsForCall[i].arg1, fake.attachCdromArgsForCall[i].arg2
}

func (fake *FakeVmxBuilder) AttachCdromReturns(result1 error) {
	fake.AttachCdromStub = nil
	fake.attachCdromReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeVmxBuilder) AttachCdromReturnsOnCall(i int, result1 error) {
	fake.AttachCdromStub = nil
	if fake.attachCdromReturnsOnCall == nil {
		fake.attachCdromReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.attachCdromReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeVmxBuilder) VMInfo(arg1 string) (driver.VMInfo, error) {
	fake.vMInfoMutex.Lock()
	ret, specificReturn := fake.vMInfoReturnsOnCall[len(fake.vMInfoArgsForCall)]
	fake.vMInfoArgsForCall = append(fake.vMInfoArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("VMInfo", []interface{}{arg1})
	fake.vMInfoMutex.Unlock()
	if fake.VMInfoStub != nil {
		return fake.VMInfoStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.vMInfoReturns.result1, fake.vMInfoReturns.result2
}

func (fake *FakeVmxBuilder) VMInfoCallCount() int {
	fake.vMInfoMutex.RLock()
	defer fake.vMInfoMutex.RUnlock()
	return len(fake.vMInfoArgsForCall)
}

func (fake *FakeVmxBuilder) VMInfoArgsForCall(i int) string {
	fake.vMInfoMutex.RLock()
	defer fake.vMInfoMutex.RUnlock()
	return fake.vMInfoArgsForCall[i].arg1
}

func (fake *FakeVmxBuilder) VMInfoReturns(result1 driver.VMInfo, result2 error) {
	fake.VMInfoStub = nil
	fake.vMInfoReturns = struct {
		result1 driver.VMInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeVmxBuilder) VMInfoReturnsOnCall(i int, result1 driver.VMInfo, result2 error) {
	fake.VMInfoStub = nil
	if fake.vMInfoReturnsOnCall == nil {
		fake.vMInfoReturnsOnCall = make(map[int]struct {
			result1 driver.VMInfo
			result2 error
		})
	}
	fake.vMInfoReturnsOnCall[i] = struct {
		result1 driver.VMInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeVmxBuilder) GetVmx(arg1 string) (*vmx.VM, error) {
	fake.getVmxMutex.Lock()
	ret, specificReturn := fake.getVmxReturnsOnCall[len(fake.getVmxArgsForCall)]
	fake.getVmxArgsForCall = append(fake.getVmxArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetVmx", []interface{}{arg1})
	fake.getVmxMutex.Unlock()
	if fake.GetVmxStub != nil {
		return fake.GetVmxStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getVmxReturns.result1, fake.getVmxReturns.result2
}

func (fake *FakeVmxBuilder) GetVmxCallCount() int {
	fake.getVmxMutex.RLock()
	defer fake.getVmxMutex.RUnlock()
	return len(fake.getVmxArgsForCall)
}

func (fake *FakeVmxBuilder) GetVmxArgsForCall(i int) string {
	fake.getVmxMutex.RLock()
	defer fake.getVmxMutex.RUnlock()
	return fake.getVmxArgsForCall[i].arg1
}

func (fake *FakeVmxBuilder) GetVmxReturns(result1 *vmx.VM, result2 error) {
	fake.GetVmxStub = nil
	fake.getVmxReturns = struct {
		result1 *vmx.VM
		result2 error
	}{result1, result2}
}

func (fake *FakeVmxBuilder) GetVmxReturnsOnCall(i int, result1 *vmx.VM, result2 error) {
	fake.GetVmxStub = nil
	if fake.getVmxReturnsOnCall == nil {
		fake.getVmxReturnsOnCall = make(map[int]struct {
			result1 *vmx.VM
			result2 error
		})
	}
	fake.getVmxReturnsOnCall[i] = struct {
		result1 *vmx.VM
		result2 error
	}{result1, result2}
}

func (fake *FakeVmxBuilder) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.initHardwareMutex.RLock()
	defer fake.initHardwareMutex.RUnlock()
	fake.addNetworkInterfaceMutex.RLock()
	defer fake.addNetworkInterfaceMutex.RUnlock()
	fake.setVMResourcesMutex.RLock()
	defer fake.setVMResourcesMutex.RUnlock()
	fake.attachDiskMutex.RLock()
	defer fake.attachDiskMutex.RUnlock()
	fake.detachDiskMutex.RLock()
	defer fake.detachDiskMutex.RUnlock()
	fake.attachCdromMutex.RLock()
	defer fake.attachCdromMutex.RUnlock()
	fake.vMInfoMutex.RLock()
	defer fake.vMInfoMutex.RUnlock()
	fake.getVmxMutex.RLock()
	defer fake.getVmxMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeVmxBuilder) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ driver.VmxBuilder = new(FakeVmxBuilder)
